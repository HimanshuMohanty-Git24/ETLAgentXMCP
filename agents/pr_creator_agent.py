"""
Pull Request Creator Agent.

Creates GitHub PRs for each layer transformation with detailed descriptions.
Does NOT use LLM - direct GitHub API integration.

Author: Data Engineering Team
Date: 2025-11-14
"""

from state import ETLState
from tools.github_tools import create_github_pr
from datetime import datetime


class PRCreatorAgent:
    """
    Creates separate GitHub PR for each layer transformation.
    
    Each layer (Bronze, Silver, Gold) gets its own PR for granular review.
    PRs include context from the transformation plan and code quality metrics.
    """
    
    def __init__(self):
        """Initialize PR Creator Agent."""
        print("PRCreatorAgent initialized")
    
    async def __call__(self, state: ETLState) -> ETLState:
        """
        Create layer-specific GitHub pull request.
        
        Creates a PR with:
        - Layer-specific branch name
        - Detailed description with transformation context
        - Code quality metrics
        - Links to previous layers if applicable
        
        Args:
            state: Current ETL pipeline state
        
        Returns:
            Updated state with PR information
        """
        # Check if code was approved
        if state["review_status"] != "APPROVED":
            error_msg = f"Cannot create PR for {state['current_layer']}: Code not approved (status: {state['review_status']})"
            state["error_log"].append(error_msg)
            print(f"[ERROR] {error_msg}")
            return state
        
        current_layer = state["current_layer"]
        
        # Build PR context based on completed layers
        pr_context = self._build_pr_context(state, current_layer)
        
        # Create descriptive PR
        task_name = f"{current_layer}_layer_{state['user_query'][:30].replace(' ', '_')}"
        
        # Build comprehensive PR body
        pr_plan = f"""
## {current_layer.upper()} Layer Transformation

### User Request
{state['user_query']}

### Layer Context
{pr_context}

### Transformation Plan
{state['transformation_plan']}

### Code Quality
- **Review Status**: {state['review_status']}
- **Quality Score**: {state['code_quality_score']}/100
- **Tests**: {"[OK] Included" if state['test_code'] else "[MISSING] Not included"}
- **Layer**: {current_layer.upper()}

### Related PRs
{self._format_related_prs(state)}

### Review Checklist
- [ ] Code follows Databricks best practices
- [ ] Delta Lake features properly configured
- [ ] Tests cover edge cases and data quality
- [ ] No hardcoded credentials or secrets
- [ ] Proper error handling implemented
- [ ] Performance optimizations in place

### Execution Order
This is part of a multi-layer Medallion pipeline. **Review carefully before merging.**
After merge, the code will be executed automatically on Databricks.

---
*Generated by Medallion ETL Agentic System using Databricks Claude Sonnet 4.5*
"""
        
        try:
            # Create PR via GitHub API
            pr_result = create_github_pr.invoke({
                "task_name": task_name,
                "pyspark_code": state["pyspark_code"] or state["sql_queries"][0] if state["sql_queries"] else "# No code generated",
                "test_code": state["test_code"],
                "plan": pr_plan
            })
            
            if pr_result["status"] == "success":
                state["current_pr_url"] = pr_result["pr_url"]
                state["current_pr_number"] = pr_result["pr_number"]
                state["current_pr_merged"] = False
                
                # Track in PR history
                state["pr_history"].append({
                    "layer": current_layer,
                    "pr_number": pr_result["pr_number"],
                    "pr_url": pr_result["pr_url"],
                    "branch_name": pr_result.get("branch_name", ""),
                    "created_at": datetime.now().isoformat(),
                    "quality_score": state["code_quality_score"]
                })
                
                state["workflow_status"] = f"{current_layer}_pr_created"
                
                print(f"[OK] PR #{pr_result['pr_number']} created for {current_layer.upper()} layer")
                print(f"  URL: {pr_result['pr_url']}")
            else:
                error_msg = f"PR creation failed for {current_layer}: {pr_result.get('error', 'Unknown error')}"
                state["error_log"].append(error_msg)
                print(f"[ERROR] {error_msg}")
        
        except Exception as e:
            error_msg = f"Exception creating PR for {current_layer}: {str(e)}"
            state["error_log"].append(error_msg)
            print(f"[ERROR] {error_msg}")
        
        state["current_agent"] = "pr_creator"
        
        return state
    
    def _build_pr_context(self, state: ETLState, layer: str) -> str:
        """Build context section for PR description."""
        if layer == "bronze":
            return f"""
**Source**: `{state['source_table']}`
**Purpose**: Initial raw data ingestion with audit trail
**Target**: Bronze layer table with metadata columns
"""
        
        elif layer == "silver":
            bronze = state.get("bronze_context")
            if bronze:
                return f"""
**Source**: `{bronze['table_name']}` (Bronze layer)
**Input Rows**: {bronze['row_count']:,}
**Input Quality**: {bronze['data_quality_metrics']['completeness_ratio']*100:.1f}% complete
**Purpose**: Clean, deduplicate, and validate Bronze data
**Target**: Silver layer table with quality flags
"""
        
        else:  # gold
            silver = state.get("silver_context")
            if silver:
                return f"""
**Source**: `{silver['table_name']}` (Silver layer)
**Input Rows**: {silver['row_count']:,}
**Input Quality**: {silver['data_quality_metrics']['completeness_ratio']*100:.1f}% complete
**Purpose**: Create business-ready aggregations and KPIs
**Target**: Gold layer fact and dimension tables
"""
        
        return f"**Source**: {state['source_table']}\n**Purpose**: {layer.upper()} layer transformation"
    
    def _format_related_prs(self, state: ETLState) -> str:
        """Format list of related PRs from previous layers."""
        if not state["pr_history"]:
            return "No previous PRs (this is the first layer)"
        
        lines = []
        for pr in state["pr_history"]:
            status = "[OK] Merged" if pr.get("merged", False) else "[PENDING] Awaiting Merge"
            lines.append(f"- [{pr['layer'].upper()}] PR #{pr['pr_number']}: {status} - {pr['pr_url']}")
        
        return "\n".join(lines) if lines else "None"
